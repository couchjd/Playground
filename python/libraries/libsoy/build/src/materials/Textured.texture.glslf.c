char* soy_materials_textured_texture_glslf = "/*\n*  libsoy - soy.materials.Textured.texture_glslf\n*  Copyright (C) 2006-2014 Copyleft Games Group\n*\n*  This program is free software; you can redistribute it and/or modify\n*  it under the terms of the GNU Affero General Public License as published\n*  by the Free Software Foundation, either version 3 of the License, or\n*  (at your option) any later version.\n*\n*  This program is distributed in the hope that it will be useful,\n*  but WITHOUT ANY WARRANTY; without even the implied warranty of\n*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n*  GNU Affero General Public License for more details.\n*\n*  You should have received a copy of the GNU Affero General Public License\n*  along with this program; if not, see http://www.gnu.org/licenses\n*\n*/\n\n// https://imdoingitwrong.wordpress.com/2011/02/10/improved-light-attenuation/\n\nprecision mediump float;\nuniform vec4 scene_ambient;\nuniform vec4 light_diffuse[8], light_specular[8];\nuniform vec4 mat_ambient, mat_diffuse, mat_specular;\nuniform vec4 mat_emission;\nuniform float mat_shininess;\nuniform sampler2D colormap, glowmap, bumpmap;\nuniform samplerCube colormap_cube, glowmap_cube, bumpmap_cube;\nuniform vec3 light_pos[8];\nuniform int light_num;\nvarying vec3 vVertex, vVertexRaw, vNormal, vTangent;\nvarying vec2 vTexCoordColor, vTexCoordGlow, vTexCoordBump;\n\nvoid main() {\nvec3 texN = vec3(textureCube(bumpmap_cube, normalize(\nvVertexRaw))+texture2D(bumpmap,vTexCoordBump))\n* 2.0 - 1.0;\nvec3 tangentN = normalize(vNormal);\nvec3 tangentT = normalize(vTangent);\nvec3 tangentB = normalize(cross(tangentN,tangentT));\nvec3 n = mat3(tangentT,tangentB,tangentN) * texN;\nvec3 v = normalize(-vVertex);\n\nvec4 totalDiffuse = mat_ambient * scene_ambient;\nvec4 totalSpecular = vec4(0.0);\n\n// FIXME raising loop count breaks on RPI\nfor (int i = 0; i < 4; i++) {\nif (i >= light_num) {break;}\nvec3 l = light_pos[i]-vVertex;\nfloat d = length(l);\nif (d > 20.0) {continue;}\nl /= d;\nvec3 h = normalize(l+v);\nfloat d2 = d/(1.0-pow(d/20.0,2.0));\nfloat attenuation = 1.0/pow(1.0 + 0.01*d2,2.0);\ntotalDiffuse += max(dot(l, n), 0.0) * mat_diffuse *\nlight_diffuse[i] * attenuation;\ntotalSpecular += pow(max(dot(n, h), 0.0), mat_shininess)\n* mat_specular * light_specular[i] *\nattenuation;\n}\n\nvec3 vertexNorm = normalize(vVertexRaw);\ngl_FragColor = (totalDiffuse*(textureCube(colormap_cube\n,vertexNorm)+texture2D(colormap,\nvTexCoordColor)) + totalSpecular) +\nmat_emission + textureCube(glowmap_cube,\nvertexNorm) + texture2D(glowmap,\nvTexCoordGlow);\n}\n\n";